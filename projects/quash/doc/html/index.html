<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=9" />
  <meta name="generator" content="Doxygen 1.8.13" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Quash Shell: Main Page</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="search/searchdata.js"></script>
  <script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>

<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
      <table cellspacing="0" cellpadding="0">
        <tbody>
          <tr style="height: 56px;">
            <td id="projectalign" style="padding-left: 0.5em;">
              <div id="projectname">Quash Shell
                &#160;<span id="projectnumber">0.1</span>
              </div>
              <div id="projectbrief">A simple yet powerfull shell program</div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- end header part -->
    <!-- Generated by Doxygen 1.8.13 -->

    <script type="text/javascript" src="menudata.js"></script>
    <script type="text/javascript" src="menu.js"></script>
    <script type="text/javascript">
      $(function () {
        initMenu('', true, false, '', '');
        $(document).ready(function () { init_search(); });
      });
    </script>
    <div id="main-nav"></div>
    
  </div><!-- top -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()"
    onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>

  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow">
    <iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
    </iframe>
  </div>

  <div class="header">
    <div class="headertitle">
      <div class="title">Quash Shell Documentation</div>
    </div>
  </div><!--header-->

  <div class="contents">
    <div class="textblock">
      <blockquote class="doxtable">
        <h1>EECS 678 - Quash Shell</h1>
        <p></p>
      </blockquote>
      <h2>Introduction</h2>
      <p>In this project, you will complete the Quite a Shell (quash) program using the UNIX system calls. You may work
        in groups of 2. The purpose of this project is as follows:</p>
      <ul>
        <li>Getting familiar with the Operating System (UNIX) interface.</li>
        <li>Exercising UNIX system calls.</li>
        <li>Understanding the concept of a process from the user point of view.</li>
      </ul>
      <p>
        In essence, Quash should behave similar to csh, bash or other popular shell programs.
        <strong>You must use C, C++, Rust, or Go to implement this project.</strong>
      </p>

      <h2>Features</h2>
      <p>The following features should be implemented in Quash:</p>
      <ul>
        <li>Quash should be able to run executables (the basic function of a shell) with command line parameters</li>
        <li>If the executable is not specified in the absolute or relative path format (starting with sequences of ‘/’,
          './', or '../'), quash should search the directories in the environment variable PATH (see below). If no
          executable file is found, quash should print an error message to standard error. Quash should allow both
          foreground and background executions. Character ‘&amp;’ is used to indicate background execution. Commands
          without ‘&amp;’ are assumed to run in foreground.<ul>
            <li>When a command is run in the background, quash should print: "Background
              job started: [JOBID] PID COMMAND"</li>
            <li>When a background command finishes, quash should print: "Completed:
              [JOBID] PID COMMAND"</li>
          </ul>
        </li>
      </ul>
      <pre>
        <code>
        [QUASH]$ program1 &amp;
        Background job started: [1] 2342 program1 &amp;
        [QUASH]$ ls
        Documents Downloads
        Completed: [1] 2342 program1 &amp;
        </code>
      </pre>

      <ul>
        <li>Quash should implement I/O redirection. The <code>&lt;</code> character is used to redirect the standard
          input from a file. The <code>&gt;</code> character is used to redirect the standard output to a file while
          truncating the file. The <code>&gt;&gt;</code> string is used to redirect the standard output to a file while
          appending the output to the end of the file.</li>
      </ul>
      <pre>
        <code>
        [QUASH]$ echo Hello Quash! &gt; a.txt  # Write "Hello Quash!\n" to a file
        [QUASH]$ cat a.txt
        Hello Quash!
        [QUASH]$ echo Hey Quash! &gt; a.txt  # Trucates/overwrites a.txt contents
        [QUASH]$ cat a.txt          # Print file contents
        Hey Quash!
        [QUASH]$ cat &lt; a.txt        # Make cat read from a.txt via standard in
        Hey Quash!
        [QUASH]$ cat &lt; a.txt &gt; b.txt  # Multiple redirect. Read from a.txt and write to b.txt.
        [QUASH]$ cat b.txt
        Hey Quash!
        [QUASH]$ cat a.txt &gt;&gt; b.txt  # Append output of a.txt to b.txt
        [QUASH]$ cat b.txt
        Hey Quash!
        Hey Quash!
        [QUASH]$
        </code>
      </pre>

      <ul>
        <li>Quash should support pipes <code>|</code>.</li>
      </ul>
      <pre>
        <code>
        [QUASH]$ cat src/quash.c | grep running
        // Check if loop is running
        bool is_running() {
          return state.running;
          state.running = false;
          while (is_running()) {
        [QUASH]$ cat src/quash.c | grep running | grep return
          return state.running;
        </code>
      </pre>

      <ul>
        <li>Quash should support comments # this is a comment. Quash should parse and interpret anything before the '#'
          character if applicable, and discard anything after it.</li>
      </ul>

      <pre>
        <code>
        [QUASH]$ echo "hello world" # this is a comment
        hello world
        [QUASH]$ # this is another comment -&gt; Quash does nothing
        [QUASH]$
        </code>
      </pre>

      <h3>Built-in Functions</h3>
      <p>All built-in commands should be implemented in quash itself. They cannot be external programs of any kind.
        Quash should support the following built-in functions:</p>
      <ul>
        <li><code>echo</code> - Print a string given as an argument. The output format should be the same as bash (a
          string followed by new line '\n')</li>
      </ul>
      <pre>
        <code>
        [QUASH]$ echo Hello world! 'How are you today?'
        Hello world! How are you today?
        [QUASH]$ echo $HOME/Development
        /home/jrobinson/Development
        [QUASH]$ echo "Double quoted string" 12345
        Double quoted string 12345
        [QUASH]$
        </code>
      </pre>
      <ul>
        <li>export - Sets the value of an environment variable. Quash should support reading from and writing to
          environment variables.</li>
      </ul>
      <pre>
        <code>
        [QUASH]$ export PATH=/usr/bin:/bin  # Set the PATH environment variable
        [QUASH]$ echo $PATH                 # Print the current value of PATH
        /usr/bin:/bin
        [QUASH]$ echo $HOME
        /home/jrobinson
        [QUASH]$ export PATH=$HOME  # Set the PATH environment variable to the value of HOME
        [QUASH]$ echo $PATH         # Print the current value of PATH
        /home/jrobinson
        [QUASH]$
        </code>
      </pre>

      <ul>
        <li><code>cd</code> - Change current working directory. This updates both the actual working directory and the
          PWD environment variable.</li>
      </ul>
      <pre>
        <code>
        [QUASH]$ echo $PWD
        /home/jrobinson
        [QUASH]$ cd ..              # Go up one directory
        [QUASH]$ echo $PWD
        /home
        [QUASH]$ cd $HOME           # Go to path in the HOME environment variable
        /home/jrobinson
        [QUASH]$
        </code>
        </pre>

        <ul>
          <li><code>pwd</code> - Print the absolute path of the current working directory. Make sure you are printing
            out
            the actual working directory and not just the PWD environment variable.</li>
        </ul>
        <pre>
        <code>
        [QUASH]$ pwd                # Print the working directory
        /home/jrobinson
        [QUASH]$ echo $PWD          # Print the PWD environment variable
        /home/jrobinson
        [QUASH]$ export PWD=/usr    # Change the PWD environment variable
        [QUASH]$ pwd
        /home/jrobinson
        [QUASH]$ echo $PWD
        /usr
        [QUASH]$
        </code>
      </pre>
        <ul>
          <li><code>quit</code> &amp; <code>exit</code> - Use these to terminate quash. These are already implemented
            for
            you.</li>
        </ul>
        <pre>
        <code>
        [BASH]$ ./quash
        Welcome...
        [QUASH]$ exit
        [BASH]$ ./quash
        Welcome...
        [QUASH]$ quit
        [BASH]$
        </code>
      </pre>

        <ul>
          <li><code>jobs</code> - Should print all of the currently running background processes in the format: "[JOBID]
            PID COMMAND" where JOBID is a unique positive integer quash assigns to the job to identify it, PID is the
            PID
            of the child process used for the job, and COMMAND is the command used to invoke the job.</li>
        </ul>
        <pre>
        <code>
        [QUASH]$ find -type f | grep '*.c' &gt; out.txt &amp;
        Background job started: [1] 2342 find / -type f | grep '*.c' &gt; out.txt &amp;
        [QUASH]$ sleep 15 &amp;
        Background job started: [2] 2343 sleep 15 &amp;
        [QUASH]$ jobs               # List currently running background jobs
        [1] 2342 find / -type f | grep '*.c' &gt; out.txt &amp;
        [2] 2343 sleep 15 &amp;
        [QUASH]$
        </code>
      </pre>

        <ul>
          <li>
            <code>kill</code> - Given a POSIX signal number (int) and a PID (int), Quash should send the signal to the
            given process. The format shall be <code>kill SIGNUM PID</code>.
          </li>
        </ul>

        <pre>
        <code>
        [QUASH]$ sleep 100 &amp;
        Background job started: [1] 4071 sleep 100 &amp;
        [QUASH]$ kill 2 4071         # send SIGINT signal to PID 4071
        [QUASH]$ jobs                # the process was terminated => no output
        [QUASH]$
        </code>
      </pre>


        <h2>Useful System Calls and Library Functions</h2>
        <p>The following is a list and brief description of some system calls and library functions you may want to use
          and their respective man page entries. Note that this list may not be exhaustive, but be sure what ever
          library
          functions you use will run on the lab machines:</p>
        <ul>
          <li>atexit(3) - Enroll functions that should be called when exit(3) is called</li>
          <li>chdir(2) - Changes the current working directory</li>
          <li>close(2) - Closes a file descriptor</li>
          <li>dup2(2) - Copies a file descriptor into a specified entry in the file descriptor table</li>
          <li>execvp(3) - Replaces the current process with a new process</li>
          <li>exit(3) - Imediately terminate the current process with an exit status</li>
          <li>fork(2) - Creates a new process by duplicating the calling process</li>
          <li>getenv(3) - Reads an environment variable from the current process environment</li>
          <li>getwd(3) - Gets the current working directory as a string (get_current_dir_name(3) may be easier to use)
          </li>
          <li>get_current_dir_name(3) - Gets the current working directory and stores it in a newly allocated string
          </li>
          <li>kill(2) - Sends a signal to a process with a given pid</li>
          <li>open(2) - Opens a file descriptor with an entry at the specified path in the file system</li>
          <li>pipe(2) - Creates a unidirectional communication pathway between two processes</li>
          <li>printf(3) - Prints to the standard out (see also fprintf)</li>
          <li>setenv(3) - Sets an environment variable in the current process environment</li>
          <li>waitpid(2) - Waits or polls for a process with a given pid to finish</li>
        </ul>

        <p>You may NOT use the system(3) function anywhere in your project</p>
        <h2>Project Hints and Comments</h2>
        <p>In Quash, a job is defined as a single command or a list of commands separated by pipes. For example the
          following are each one job:</p>
        <pre>
      <code>
      cat file.txt       # A job with a single process running under it
      find | grep *.qsh  # A job with two processes running under it
      </code>
      </pre>
        <p>
          A job may contain more than one process and should have a unique id for the current list of
          jobs in Quash, a knowledge of all of the pids for processes that run under it, and an expanded string
          depicting what was typed in on the command line to create that job. When passing the pid to the various print
          job functions you just need to give one pid associated with the job. The job id should also be assigned in a
          similar manner
          as bash assigns them. That is the job id of a new background job is one greater than the maximum job id in the
          background job list.
          Experiment with background jobs in Bash for more details on the id assignment.
        </p>

        <!--<h2>Testing</h2>
        <p>There is an automated testing script written for this project in run_tests.bash. Using the "make test" target
          in the make file will run the ./run-tests.bash command present in the Makefile. If you want more control you
          may
          run this script directly from the command line with "./run_tests.bash [-cdstuv]". The various options are
          listed
          below or with "./run_tests.bash -h".</p>
        <ul>
          <li>-c Clean up all files created during testing.</li>
          <li>-d If there is a difference between what is seen and what is expected this option will immediately print
            out
            the diff file rather than telling you where you can find the diff file.</li>
          <li>-p Allow all tests to be run in parallel as background processes. This will greatly speed up the testing
            process but output to the command line will be scattered.</li>
          <li>-s Keep the sandbox directory around after testing (this is a debug option for the tester and probably not
            of much use unless modifying run-tests.bash).</li>
          <li>-t Keep the the temporary directory "test-cases/&lt;test-name-dir&gt;/.tmp" around after tests are
            complete
            (this is a debug option for the tester and probably not of much use unless modifying run-tests.bash).</li>
          <li>-v Print out all output from the test case if diff picked up any differences between the test output and
            expected output.</li>
        </ul>-->


        <h2>Grading Policy</h2>
        <p>Partial credit will be given for incomplete programs. However, a program that cannot compile will get 0
          points.
          The feature tests are placed into multiple tiers of completeness. The output to standard out from your code
          must
          match our output exactly, except for whitespace, for the next tier of grading to be accessible. This is due to
          reliance of previous tiers in subsequent tier tests. If we cannot run your code in one tier then it becomes
          far
          more difficult test later tiers. The point breakdown for features is below:</p>
        <table class="doxtable">
          <tr>
            <th>Description </th>
            <th>Score </th>
          </tr>
          <tr>
            <td>
              <ul>
                <li>
                  Tier 0 <ul>
                    <li>
                      Quash compiles </li>
                  </ul>
                </li>
              </ul>
            </td>
            <td>10% </td>
          </tr>
          <tr>
            <td>
              <ul>
                <li>
                  Tier 1 <ul>
                    <li>
                      Single commands without arguments (ls) </li>
                    <li>
                      Simple built-in commands <ul>
                        <li>
                          pwd </li>
                        <li>
                          echo with a single argument </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </td>
            <td>30% </td>
          </tr>
          <tr>
            <td>
              <ul>
                <li>
                  Tier 2 <ul>
                    <li>
                      Single commands with arguments (ls -a /) </li>
                    <li>
                      Built-in commands <ul>
                        <li>
                          echo with multiple arguments </li>
                        <li>
                          cd </li>
                        <li>
                          export </li>
                      </ul>
                    </li>
                    <li>
                      Environment Variables <ul>
                        <li>
                          echo with environment variables (echo $HOME) </li>
                        <li>
                          Execution with environment variables (du -H $PWD/..) </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </td>
            <td>30% </td>
          </tr>
          <tr>
            <td>
              <ul>
                <li>Tier 3</li>
                <ul>
                  <li>Built-in commands</li>
                  <ul>
                    <li>jobs</li>
                    <li>kill</li>
                  </ul>
                  <li>Piping output between one command and another (find -type f | grep '*.c')</li>
                  <li>Redirect standard input to any command from file (cat < a.txt)</li>
                  <li>Redirect standard output from a command to a file (cat b.txt > a.txt)</li>
                  <li>Background processes</li>
                  <ul>
                    <li>Job completion notification</li>
                  </ul>
                </ul>
              </ul>
            </td>
            <td>30% </td>
          </tr>
          <tr>
            <td>
              <ul>
                <li>
                  Tier 4 (extra credit) <ul>
                    <li>
                      Pipes and redirects can be mixed (cat &lt; a.txt | grep -o World | cat &gt; b.txt) </li>
                    <li>
                      Pipes and redirects work with built-in commands </li>
                    <li>
                      Append redirection (cat a.txt | grep -o World &gt;&gt; b.txt) </li>
                  </ul>
                </li>
              </ul>
            </td>
            <td>10% </td>
          </tr>
          <tr>
            <td>
              <ul>
                <li>
                  Valgrind Memory Errors <ul>
                    <li>
                      While not ideal, you will not lose any points for "still reachable" blocks </li>
                    <li>
                      Unacceptable Memory Leaks <ul>
                        <li>
                          Definately lost </li>
                        <li>
                          Indirectly lost </li>
                        <li>
                          Possibly lost </li>
                      </ul>
                    </li>
                    <li>
                      Unacceptable Access Violations <ul>
                        <li>
                          Invalid Read </li>
                        <li>
                          Invalid Write </li>
                        <li>
                          Invalid free </li>
                        <li>
                          Use of uninitialized values </li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </td>
            <td>-5% from tier grade down to 0% for each tier with violations </td>
          </tr>
        </table>
        <h2>Submission</h2>
        <p>
          Each group (or individual) should submit the project via Canvas. The following will be expected in your
          deliverables:
        </p>

        <ul>
          <li>Source code files (.c, .cpp, .h, .rs, .go)</li>
          <li>Makefile with the <code>quash</code> target defined</li>
          <li>If using Rust or Go, include an 'instructions.txt' file for building and running your program. Include the
            language version and other potentially helpful information.</li>
        </ul>

        <p>
          Create a tar.gz archive of your deliverables. The TA should be able to run <code>make quash</code> to build
          your <code>quash</code> executable and then run <code>./quash</code> to execute your program. Ensure your code
          compiles and executes on the EECS cycle servers (if C/C++).
        </p>
        <p>Start early! GOOD LUCK. </p>
    </div>
  </div>
</body>

</html>
